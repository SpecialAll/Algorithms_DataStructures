package com.zxh.algorithms.interview.alibaba;

/**
 * @version 1.0
 * @Author ningque
 * @Date 2020/3/4
 */

public class Test {
    /**
     * 求解最大黑色区域面积的方法
     *
     * @param array    二维数组表示查找的区域
     * @return         返回int类型的黑色区域面积
     */
    public int maxAreaOfBlack(int[][] array){
        int M = array.length;
        if(M == 0)
            return 0;
        int N = array[0].length;
        //记录黑色区域面积
        int max = 0;
        for(int i=0; i<M; i++){
            for(int j=0; j<N; j++){
                //如果当前位置是黑色的话就去查找搜索相邻节点位置
                if(array[i][j] == 1){
                    //通过DFS搜索去查找相邻节点
                    int num = check(array, i, j);
                    max = num>max ? num : max;
                }
            }
        }
        return max;
    }
    /**
     * 使用DFS搜索，递归查询相邻节点。
     *
     * @param array  二维数组
     * @param i      数组行下标
     * @param j      数组列下标
     * @return       返回int类型的黑色节点个数
     */
    private int check(int[][] array, int i, int j) {
        //当前节点为黑色，Count初始化为1
        int count = 1;
        //如果访问过，则将value设为0（避免重复访问）
        array[i][j] = 0;
        //搜索当前节点左边相邻节点
        if(i-1 >= 0 && array[i-1][j] == 1){
            count += check(array,i-1, j);
        }
        //搜索当前节点右边相邻节点
        if(i+1 < array.length && array[i+1][j] == 1){
            count += check(array, i+1, j);
        }
        //搜索当前节点上面相邻节点
        if(j-1 >= 0 && array[i][j-1] == 1){
            count += check(array, i, j-1);
        }
        //搜索当前节点下面相邻节点
        if(j+1 < array[0].length && array[i][j+1] == 1){
            count += check(array, i, j+1);
        }
        return count;
    }

    public static void main(String[] args) {
        Test test = new Test();
        /**
         * 测试用例-1： 一般用例，它的黑色区域面积为6
         *  [[0,0,1,0,0,0,0,1,0,0,0,0,0],
         *  [0,0,0,0,0,0,0,1,1,1,0,0,0],
         *  [0,1,1,0,1,0,0,0,0,0,0,0,0],
         *  [0,1,0,0,1,1,0,0,1,0,1,0,0],
         *  [0,1,0,0,1,1,0,0,1,1,1,0,0],
         *  [0,0,0,0,0,0,0,0,0,0,1,0,0],
         *  [0,0,0,0,0,0,0,1,1,1,0,0,0],
         *  [0,0,0,0,0,0,0,1,1,0,0,0,0]]
         */
        int[][] array1 = {{0,0,1,0,0,0,0,1,0,0,0,0,0},
                        {0,0,0,0,0,0,0,1,1,1,0,0,0},
                        {0,1,1,0,1,0,0,0,0,0,0,0,0},
                        {0,1,0,0,1,1,0,0,1,0,1,0,0},
                        {0,1,0,0,1,1,0,0,1,1,1,0,0},
                        {0,0,0,0,0,0,0,0,0,0,1,0,0},
                        {0,0,0,0,0,0,0,1,1,1,0,0,0},
                        {0,0,0,0,0,0,0,1,1,0,0,0,0}};
        System.out.println("AreaOfBlack:" +test.maxAreaOfBlack(array1));

        /**
        * 测试用例-2：黑色区域为环状，它的黑色区域面积为8
        *  {{0,0,1,0,0,0,0,1,0,0,0,0,0},
        *  {0,0,0,0,0,0,0,1,0,0,0,0,0},
        *  {0,1,1,0,1,0,0,0,1,1,1,0,0},
        *  {0,1,0,0,1,1,0,0,1,0,1,0,0},
        *  {0,1,0,0,1,1,0,0,1,1,1,0,0},
        *  {0,0,0,0,0,0,0,0,0,0,0,0,0},
        *  {0,0,0,0,0,0,0,1,1,1,0,0,0},
        *  {0,0,0,0,0,0,0,1,1,0,0,0,0}};
        *
        */

        int[][] array2 = {{0,0,1,0,0,0,0,1,0,0,0,0,0},
                        {0,0,0,0,0,0,0,1,0,0,0,0,0},
                        {0,1,1,0,1,0,0,0,1,1,1,0,0},
                        {0,1,0,0,1,1,0,0,1,0,1,0,0},
                        {0,1,0,0,1,1,0,0,1,1,1,0,0},
                        {0,0,0,0,0,0,0,0,0,0,0,0,0},
                        {0,0,0,0,0,0,0,1,1,1,0,0,0},
                        {0,0,0,0,0,0,0,1,1,0,0,0,0}};
        System.out.println("AreaOfBlack:" +test.maxAreaOfBlack(array2));
    }
}

